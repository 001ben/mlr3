% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PredictionClassif.R
\docType{data}
\name{PredictionClassif}
\alias{PredictionClassif}
\title{Prediction Object for Classification}
\format{\link[R6:R6Class]{R6::R6Class} object inheriting from \link{Prediction}.}
\description{
This object stores the predictions returned by a learner of class \link{LearnerClassif}.
The field \code{task_type} is set to \code{"classif"}.

If probabilities are provided via construction and response is missing,
the response is calculated from the probabilities: the class label with the highest
probability is chosen. In case of ties, a label is selected randomly.

It is possible to set the probability threshold if probabilities are stored:
\itemize{
\item For binary problems only a single threshold value can be set.
If the probability exceeds the threshold, the positive class is predicted.
If the probability equals the threshold, the label is selected randomly.
\item For binary and multi-class problems, a named numeric vector of thresholds can be set.
The length and names must correspond to the number of classes and class names, respectively.
To determine the class label, the probabilities are divided by the threshold.
This results in a ratio > 1 if the probability exceeds the threshold, and a ratio < 1 otherwise.
Note that it is possible that either none or multiple ratios are greater than 1 at the same time.
Anyway, the class label with maximum ratio is determined.
In case of ties in the ratio, one of the tied class labels is selected randomly.
}
}
\note{
It is possible to initialize this object without a task, by manually providing \code{row_ids} and \code{truth}.
In this case, the class names are taken from \code{truth}, and must be identical to \code{task$class_names}
(this includes the order of the levels).
This is especially important for binary classification tasks, where the positive class must be the first level.
}
\section{Construction}{
\preformatted{p = PredictionClassif$new(task = NULL, response = NULL, prob = NULL, row_ids = task$row_ids, truth = task$truth())
}
\itemize{
\item \code{task} :: \link{TaskClassif}\cr
Task for which the predictions are made. Used to extract the row ids and the true
labels. Must be subsetted to test set.
\item \code{response} :: \code{factor()}\cr
Vector of predicted class labels.
One element for each observation in the test set.
Character vectors are automatically converted to factors.
\item \code{prob} :: \code{matrix()}\cr
Numeric matrix of class probabilities with one column for each class
and one row for each observation in the test set.
\item \code{row_ids} :: (\code{integer()} | \code{character()})\cr
Row ids of the task. Per default, these are extracted from the \code{task}.
\item \code{truth} :: \code{factor()}\cr
True (observed) labels. Per default, these are extracted from the \code{task}.
}
}

\section{Fields}{

All fields from \link{Prediction}, and additionally:
\itemize{
\item \code{threshold} :: \code{numeric(1)}\cr
Probability threshold between 0 and 1.
Assigning a value to this field modifies the stored responses.
\item \code{confusion} :: \code{matrix()}\cr
Confusion matrix resulting from the comparison of truth and response.
Truth is in columns, predicted response in rows.
}
}

\examples{
task = mlr_tasks$get("iris")
learner = mlr_learners$get("classif.rpart")
learner$predict_type = "prob"
e = Experiment$new(task, learner)$train()$predict()
p = e$prediction
p$predict_types
head(as.data.table(p))

# confusion matrix
p$confusion

# change threshold
p$threshold = mlr3misc::set_names(c(0.05, 0.9, 0.05), task$class_names)
p$confusion
}
\seealso{
Other Prediction: \code{\link{PredictionRegr}},
  \code{\link{Prediction}}
}
\concept{Prediction}
\keyword{datasets}
